/* ----------------------------------------------------------------------
! ----------------------------------------------------------------------
! Slow manifolds computation in the Tran system 
! ----------------------------------------------------------------------
! C o m p.  o f  t h e  a t t r a c t i n g  s l o w  m a n i f o l d   
! ----------------------------------------------------------------------
! Homotopy step 1: "away from the folded node along the fold curve"
! followed by
! Homotopy step 2: "away from the fold curve on the critical manifold"
! followed by
! Actual computation of the attracting slow manifold
! ----------------------------------------------------------------------
! (Ref.: Desroches, Krauskopf and Osinga, CHAOS 18, 015107 (2008))        
! ----------------------------------------------------------------------
! --------------------------------------------------------------------*/

/*
 *  Luofixedpoints_av.c
 *
 *  AUTO C file for the vector field named: Luofixedpoints
 *
 *  This file was generated by the program VFGEN, version: 2.5.0
 *  Generated on 11-Jan-2019 at 16:28
 */

#include <math.h>
#include "auto_f2c.h"

/*
 *  FUNC  Defines the vector field and its derivatives
 */

int func(integer ndim_, const doublereal *u_, const integer *icp_,
         const doublereal *par_, integer ijac_,
         doublereal *f_, doublereal *dfdu_, doublereal *dfdp_)
{
    integer dfdu__dim1, dfdp__dim1;
    const double Ki = 145.0;
    const double Nao = 140.0;
    const double Nai = 18.0;
    const double PRNaK = 1.8329999999999999e-02;
    const double R = 8.3144626181532395e+00;
    const double Kelvin = 3.1014999999999998e+02;
    const double Faraday = 9.6485332900000003e+01;
    const double cda = 9.5000000000000001e-02;
    const double cdb = 7.0000000000000007e-02;
    const double cfa = 1.2000000000000000e-02;
    const double cfb = 6.4999999999999997e-03;
    const double cxa = 5.0000000000000001e-04;
    const double cxb = 1.2999999999999999e-03;
    const double cxi = 2.8370000000000002e+00;
    const double cK1a = 1.0200000000000000e+00;
    const double cK1b = 4.9124000000000001e-01;
    const double Vda = -5.0000000000000000e+00;
    const double Vdb = 4.4000000000000000e+01;
    const double Vfa = 2.8000000000000000e+01;
    const double Vfb = 3.0000000000000000e+01;
    const double Vxa = 5.0000000000000000e+01;
    const double Vxb = 2.0000000000000000e+01;
    const double Vxi1 = 7.7000000000000000e+01;
    const double Vxi2 = 3.5000000000000000e+01;
    const double sda1 = -1.0000000000000000e-02;
    const double sda2 = -7.1999999999999995e-02;
    const double sdb1 = -1.7000000000000001e-02;
    const double sdb2 = 5.0000000000000003e-02;
    const double sfa1 = -8.0000000000000002e-03;
    const double sfa2 = 1.4999999999999999e-01;
    const double sfb1 = -2.0000000000000000e-02;
    const double sfb2 = -2.0000000000000001e-01;
    const double sxa1 = 8.3000000000000004e-02;
    const double sxa2 = 5.7000000000000002e-02;
    const double sxb1 = -5.9999999999999998e-02;
    const double sxb2 = -4.0000000000000001e-02;
    const double sxi = 4.0000000000000001e-02;
    const double sK1a = 2.3849999999999999e-01;
    const double sK1b1 = 8.0320000000000003e-02;
    const double sK1b2 = 6.1749999999999999e-02;
    const double sK1b3 = -5.1429999999999998e-01;
    const double sKp = 1.6722408026755853e-01;
    const double gK1w = 6.0470000000000002e-01;
    const double gKp = 1.8300000000000000e-02;
    const double gb = 3.9210000000000002e-02;
    const double VKp = 7.4880000000000004e+00;
    const double Vb = 5.9869999999999997e+01;
    double V, d, f, x;
    double C, Ko, shiftd, shiftf, gKw, gCa, VCa, T;
    double gK, gK1, VK, VK1, alphad_inf, betad_inf, alphad_tau, betad_tau, alphaf_inf, betaf_inf, alphaf_tau, betaf_tau, alphax, betax, taud, tauf, taux, dinf, finf, xinf, xi, alphaK1, betaK1, K1inf, Kp, ICa, IK, IK1, IKp, Ib;

    dfdu__dim1 = ndim_;
    dfdp__dim1 = ndim_;

    V          = u_[0];
    d          = u_[1];
    f          = u_[2];
    x          = u_[3];

    C          = par_[0];
    Ko         = par_[1];
    shiftd     = par_[2];
    shiftf     = par_[3];
    gKw        = par_[4];
    gCa        = par_[5];
    VCa        = par_[6];
    T          = par_[10];

    gK = 4.3033148291193524e-01*gKw*pow(Ko,(1.0/2.0));
    gK1 = 4.3033148291193524e-01*pow(Ko,(1.0/2.0))*gK1w;
    VK = 1.0/Faraday*log(( PRNaK*Nao+Ko)/( Ki+PRNaK*Nai))*R*Kelvin;
    VK1 = 1.0/Faraday*R*log(1.0/Ki*Ko)*Kelvin;
    alphad_inf = cda/( exp(sda2*( Vda-shiftd+V))+1.0)*exp(sda1*( Vda-shiftd+V));
    betad_inf = 1.0/( exp(( Vdb-shiftd+V)*sdb2)+1.0)*exp(( Vdb-shiftd+V)*sdb1)*cdb;
    alphad_tau = exp(( Vda+V)*sda1)/( exp(sda2*( Vda+V))+1.0)*cda;
    betad_tau = 1.0/( exp(sdb2*( Vdb+V))+1.0)*exp(sdb1*( Vdb+V))*cdb;
    alphaf_inf = cfa/( exp(-sfa2*( shiftf-V-Vfa))+1.0)*exp(-sfa1*( shiftf-V-Vfa));
    betaf_inf = cfb*exp(-sfb1*( shiftf-Vfb-V))/( exp(-sfb2*( shiftf-Vfb-V))+1.0);
    alphaf_tau = cfa*exp(sfa1*( V+Vfa))/( exp(sfa2*( V+Vfa))+1.0);
    betaf_tau = cfb/( exp(sfb2*( Vfb+V))+1.0)*exp(sfb1*( Vfb+V));
    alphax = 1.0/( exp(( Vxa+V)*sxa2)+1.0)*cxa*exp(( Vxa+V)*sxa1);
    betax = 1.0/( exp(( Vxb+V)*sxb2)+1.0)*exp(( Vxb+V)*sxb1)*cxb;
    taud = 1.0/( alphad_tau+betad_tau);
    tauf = 1.0/( alphaf_tau+betaf_tau);
    taux = 1.0/( alphax+betax);
    dinf = 1.0/( betad_inf+alphad_inf)*alphad_inf;
    finf = alphaf_inf/( alphaf_inf+betaf_inf);
    xinf = alphax/( alphax+betax);
    xi = cxi/( Vxi1+V)/exp(sxi*( Vxi2+V))*( exp(( Vxi1+V)*sxi)-1.0);
    alphaK1 = 1.0/( exp(-( VK1-V+5.9215000000000003e+01)*sK1a)+1.0)*cK1a;
    betaK1 = 1.0/( exp(-( VK1-V-4.7530000000000001e+00)*sK1b3)+1.0)*( exp(-sK1b2*( VK1-V+5.9430999999999995e+02))+cK1b*exp(-sK1b1*( VK1-V-5.4760000000000000e+00)));
    K1inf = alphaK1/( alphaK1+betaK1);
    Kp = 1.0/( exp(sKp*( VKp-V))+1.0);
    ICa = d*( V-VCa)*f*gCa;
    IK = -( VK-V)*gK*x*xi;
    IK1 = -( VK1-V)*K1inf*gK1;
    IKp = -( VK1-V)*Kp*gKp;
    Ib = gb*( Vb+V);

    /*
     *  The vector field
     */

    f_[0] = -( 1.0/C*(IK1+IKp+ICa+Ib+IK))*T;
    f_[1] = -1.0/C*( d-dinf)*T/taud;
    f_[2] = 1.0/tauf*T*( finf-f);
    f_[3] = T/taux*( xinf-x);

}

/*
 *  STPNT  Gives a starting point
 */

int stpnt(integer ndim_, doublereal t_, doublereal *u_, doublereal *par_)
{
    return 0;
}


/*
 *  BCND  Defines the boundary conditions
 */

int bcnd(integer ndim_, const doublereal *par_, const integer *icp_,
         integer nbc_, const doublereal *u0_, const doublereal *u1_, integer ijac_,
         doublereal *fb_, doublereal *dbc_)
{  
    const double Ki = 145.0;
    const double Nao = 140.0;
    const double Nai = 18.0;
    const double PRNaK = 1.8329999999999999e-02;
    const double R = 8.3144626181532395e+00;
    const double Kelvin = 3.1014999999999998e+02;
    const double Faraday = 9.6485332900000003e+01;
    const double cda = 9.5000000000000001e-02;
    const double cdb = 7.0000000000000007e-02;
    const double cfa = 1.2000000000000000e-02;
    const double cfb = 6.4999999999999997e-03;
    const double cxa = 5.0000000000000001e-04;
    const double cxb = 1.2999999999999999e-03;
    const double cxi = 2.8370000000000002e+00;
    const double cK1a = 1.0200000000000000e+00;
    const double cK1b = 4.9124000000000001e-01;
    const double Vda = -5.0000000000000000e+00;
    const double Vdb = 4.4000000000000000e+01;
    const double Vfa = 2.8000000000000000e+01;
    const double Vfb = 3.0000000000000000e+01;
    const double Vxa = 5.0000000000000000e+01;
    const double Vxb = 2.0000000000000000e+01;
    const double Vxi1 = 7.7000000000000000e+01;
    const double Vxi2 = 3.5000000000000000e+01;
    const double sda1 = -1.0000000000000000e-02;
    const double sda2 = -7.1999999999999995e-02;
    const double sdb1 = -1.7000000000000001e-02;
    const double sdb2 = 5.0000000000000003e-02;
    const double sfa1 = -8.0000000000000002e-03;
    const double sfa2 = 1.4999999999999999e-01;
    const double sfb1 = -2.0000000000000000e-02;
    const double sfb2 = -2.0000000000000001e-01;
    const double sxa1 = 8.3000000000000004e-02;
    const double sxa2 = 5.7000000000000002e-02;
    const double sxb1 = -5.9999999999999998e-02;
    const double sxb2 = -4.0000000000000001e-02;
    const double sxi = 4.0000000000000001e-02;
    const double sK1a = 2.3849999999999999e-01;
    const double sK1b1 = 8.0320000000000003e-02;
    const double sK1b2 = 6.1749999999999999e-02;
    const double sK1b3 = -5.1429999999999998e-01;
    const double sKp = 1.6722408026755853e-01;
    const double gK1w = 6.0470000000000002e-01;
    const double gKp = 1.8300000000000000e-02;
    const double gb = 3.9210000000000002e-02;
    const double VKp = 7.4880000000000004e+00;
    const double Vb = 5.9869999999999997e+01;
    double V0, d0, f0, x0, V1, d1, f1, x1;
    double C, Ko, shiftd, shiftf, gKw, gCa, VCa, T;
    double gK, gK1, VK, VK1, alphad_inf_0, betad_inf_0, alphad_inf_1, betad_inf_1, dinf_0, dinf_1, xi_0, xi_1, alphaK1_0, alphaK1_1, betaK1_0, betaK1_1, K1inf_0, K1inf_1, Kp_0, Kp_1, ICa_0, IK_0, IK1_0, IKp_0, Ib_0, ICa_1, IK_1, IK1_1, IKp_1, Ib_1;

    /* boundary points */

    V0          = u0_[0];
    d0          = u0_[1];
    f0          = u0_[2];
    x0          = u0_[3];

    V1          = u1_[0];
    d1          = u1_[1];
    f1          = u1_[2];
    x1          = u1_[3];

    C          = par_[0];
    Ko         = par_[1];
    shiftd     = par_[2];
    shiftf     = par_[3];
    gKw        = par_[4];
    gCa        = par_[5];
    VCa        = par_[6];
    T          = par_[10];

    /* expressions */

    gK = 4.3033148291193524e-01*gKw*pow(Ko,(1.0/2.0));
    gK1 = 4.3033148291193524e-01*pow(Ko,(1.0/2.0))*gK1w;
    VK = 1.0/Faraday*log(( PRNaK*Nao+Ko)/( Ki+PRNaK*Nai))*R*Kelvin;
    VK1 = 1.0/Faraday*R*log(1.0/Ki*Ko)*Kelvin;

    alphad_inf_0 = cda/( exp(sda2*( Vda-shiftd+V0))+1.0)*exp(sda1*( Vda-shiftd+V0));
    betad_inf_0 = 1.0/( exp(( Vdb-shiftd+V0)*sdb2)+1.0)*exp(( Vdb-shiftd+V0)*sdb1)*cdb;

    alphad_inf_1 = cda/( exp(sda2*( Vda-shiftd+V1))+1.0)*exp(sda1*( Vda-shiftd+V1));
    betad_inf_1 = 1.0/( exp(( Vdb-shiftd+V1)*sdb2)+1.0)*exp(( Vdb-shiftd+V1)*sdb1)*cdb;

    dinf_0 = 1.0/( betad_inf_0+alphad_inf_0)*alphad_inf_0;
    dinf_1 = 1.0/( betad_inf_1+alphad_inf_1)*alphad_inf_1;

    xi_0 = cxi/( Vxi1+V0)/exp(sxi*( Vxi2+V0))*( exp(( Vxi1+V0)*sxi)-1.0);
    xi_1 = cxi/( Vxi1+V1)/exp(sxi*( Vxi2+V1))*( exp(( Vxi1+V1)*sxi)-1.0);

    alphaK1_0 = 1.0/( exp(-( VK1-V0+5.9215000000000003e+01)*sK1a)+1.0)*cK1a;
    betaK1_0 = 1.0/( exp(-( VK1-V0-4.7530000000000001e+00)*sK1b3)+1.0)*( exp(-sK1b2*( VK1-V0+5.9430999999999995e+02))+cK1b*exp(-sK1b1*( VK1-V0-5.4760000000000000e+00)));
    K1inf_0 = alphaK1_0/( alphaK1_0+betaK1_0);

    alphaK1_1 = 1.0/( exp(-( VK1-V1+5.9215000000000003e+01)*sK1a)+1.0)*cK1a;
    betaK1_1 = 1.0/( exp(-( VK1-V1-4.7530000000000001e+00)*sK1b3)+1.0)*( exp(-sK1b2*( VK1-V1+5.9430999999999995e+02))+cK1b*exp(-sK1b1*( VK1-V1-5.4760000000000000e+00)));
    K1inf_1 = alphaK1_1/( alphaK1_1+betaK1_1);

    Kp_0 = 1.0/( exp(sKp*( VKp-V0))+1.0);
    Kp_1 = 1.0/( exp(sKp*( VKp-V1))+1.0);

    ICa_0 = dinf_0*( V0-VCa)*f0*gCa;
    IK_0 = -( VK-V0)*gK*x0*xi_0;
    IK1_0 = -( VK1-V0)*K1inf_0*gK1;
    IKp_0 = -( VK1-V0)*Kp_0*gKp;
    Ib_0 = gb*( Vb+V0);

    ICa_1 = dinf_1*( V1-VCa)*f1*gCa;
    IK_1 = -( VK-V1)*gK*x1*xi_1;
    IK1_1 = -( VK1-V1)*K1inf_1*gK1;
    IKp_1 = -( VK1-V1)*Kp_1*gKp;
    Ib_1 = gb*( Vb+V1);
    
    /* Left-end point: Sa intersect V=20 
    fb_[0] and fb_[1] are critical manifold */

    fb_[0] = ICa_0 + IK_0 + IK1_0 + IKp_0 + Ib_0;
    fb_[1] = d0 - dinf_0;

    fb_[2] = V0 - par_[7];
    fb_[3] = f0 - par_[9];
    fb_[4] = x0 - par_[11];
    
    /* right end-point F(V,d,f,x)=0 intersect V=-38 */   

    fb_[5] = ICa_1 + IK_1 + IK1_1 + IKp_1 + Ib_1;

    fb_[6] = V1 - par_[12];
    fb_[7] = f1 - par_[14];
    fb_[8] = x1 - par_[15];
    fb_[9] = d1 - par_[13];
 
    return 0;
}

/*
 *  ICND  Defines the integral conditions
 */

int icnd(integer ndim_, const doublereal *par_, const integer *icp_,
         integer nint_, const doublereal *u_, const doublereal *uold_,
         const doublereal *udot_, const doublereal *upold_, integer ijac_,
         doublereal *fi_, doublereal *dint_)
{
    return 0;
}

/*
 *  FOPT
 */

int fopt(integer ndim_, const doublereal *u_, const integer *icp_,
         const doublereal *par_, integer ijac_,
         doublereal *fs_, doublereal *dfdu_, doublereal *dfdp_)
{
    return 0;
}

/*
 *  PVLS
 */

int pvls(integer ndim_, const doublereal *u_, doublereal *par_)
{   
    return 0;
}
